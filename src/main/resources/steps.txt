This file is to follow the steps taken to create this project.

1. Create the repository, init with git and push it to remote
2. Create a HelloWorldResource class file which returns hello-world string at hello-world endpoint
3. For the same, add a @Controller (to specify it as a controller which routes the incoming http requests,
    and add a @RequestMapping(<endpoint>) to mention the path mapping
4. Since spring expects a view with the same name, add another annotation - @ResponseBody -> which will create a view
    with the same name to display the response

-------------------------------------------------------------------------------------------

1. Adding @ResponseBody annotation to create a view for each of the controller methods is repetitive. Hence add
    @RestController (which is a combo of @Controller and @ResponseBody)

2. Create a bean HelloWorldBean and return it. Create a new class for the same with constructor, getter, setter, etc..
    and return it. Add a corresponding endpoint to return this bean

    This bean is now being returned as a JSON. This magic is done by Jackson which maps java beans to HTTP/JSON response
    (which is further included by spring-boot-starter-web)

-----------------------------------
Path variable/Path params:

REST URIs contain complex paths, some of them even being values (Ex: /users/Bharath/todos/1 -> Bharath and 1 are values,
users and todos are path names). These are taken care by Path variable (refer /hello-world-path-param endpoint
definition for details)
**************************************************************

Building a REST API: (Prerequisites)

Key resources: Survey, Survey questions
Key Details:
    Survey -> id, title, description, questions
    Questions -> id, description, options, correct answer

1. Create Questions class with attributes, constructor, getters and toString()
2. Repeat above step for Survey class also
3. Create SurveyService (annotated with @Service to handle the business logic, and also to Spring IOC container to
    manage this bean and inject dependencies), it's attributes and a static block to initialise with some data
    (for the purpose of demonstrating this REST API)
---------------------------------------------

Survey REST API:
1. Retrieve all surveys -> GET /surveys

  a. Add a class SurveyResource as a controller, use constructor dependency injection to inject the SurveyService into
     the controller
  b. Add a method to retrieve all surveys (invoking a method call to the service class). Add a corresponding method in
     SurveyService class to retrieve the survey list, with a @RequestMapping to the getter method

2. Retrieve each survey -> GET /surveys/{surveyId}

  a. This will be done using @PathVariable
  b. Logic can be implemented by using normal java code (to iterate through the surveys list and return the survey with
     the matching id, or else null), or else it can be returned using functional programming construct (stream.filter)

  c. Success returns a 200 OK response, not found also returns a 200 (even though a null)
     Hence we need to handle it in the controller method by throwing a ResponseStatusException with 404 status

  d. To inspect the response -> right click in browser -> inspect -> network -> doc

---------------------------------------
3. Request methods for REST api:

a. GET -> retrieve details of a resource
b. POST -> create new resource
c. PUT -> Update existing resource
d. PATCH -> update part of an existing resource
e. DELETE -> delete a resource

For API response, make sure to return the right statuses as well
Ex: Resource not found -> 404, validation error -> 400, server exception -> 500, 200 -> success
    201 -> created, 204 -> no content

(refer to https://restfulapi.net/http-status-codes/)
---------------------------------
4. Exercise:
    Retrieve survey questions -> GET /surveys/{surveyId}/questions
    Retrieve survey question by Id -> GET /surveys/{surveyId}/questions/{questionId}

   Solution: Similar to the above steps (1, 2)
----------------------------------
5. a. Adding a new survey question:
        POST /surveys/{surveyId}/questions

        value = <endpoint uri>, method = Http method (GET, POST, PUT, etc..)
        @RequestBody -> used to send a request as a parameter which goes to the particular REST method

        Talend api tester -> test request api methods
        Improvements -> User must not provide the question id, it must be auto generated
                        For POST, we must not get 200 ok, we must get 201 created

    b. Improvements ->
        Auto generate ID -> Using secure random class to generate ID, then pass it to a BigInteger and set it as a
                            question id

        Proper HTTP status -> need to give 201 for created rather than 200 OK
                                we can use ResponseEntity create method

                              This can be further enhanced to return the URI location

6. Delete survey question:
    DELETE /surveys/{surveyId}/questions/{questionId}

    List.removeIf condition will allow to delete an element based on functional programming paradigm

7. Update survey question:
    PUT /surveys/{surveyId}/questions/{questionId}

8. Springboot data JPA & springboot data REST

  a.
    Spring data JPA -> provides Java Persistence API to interact with the database
    Spring data REST -> provides automatic REST endpoint creation for CRUD operations (exposing controller logic over
                        REST)

    Error:

    "Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.
    Reason: Failed to determine a suitable driver class"

    This means we need to configure datasource URL (either H2 or other DB like mysql)

    @Entity -> annotation for a class to be mapped to a DB table in JPA
    @Id -> marks an attribute as a primary key
    @GeneratedValue -> automatic generation of the value

    Once the entity is configured, go to localhost/h2-console to view the H2 DB console and see the table (User table)
    Check it's attributes.

    Repository is created to interact with entity in terms of create, read, update and delete operations (CRUD)

    JpaRepository -> Interface providing a set of methods for performing CRUD operations on a database, which will be
                     extended by our repository class. It is a generic interface taking in our entity class and it's
                     primary key
